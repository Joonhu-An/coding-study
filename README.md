# 회전행렬
 
 N*N 정사각형 기준

              회전각            |         수식 (rot[i][j]에 mat[i][j] 복사)
              
    90도 시계  (270도 반시계)    |      rot[j][N-1-i] = mat[i][j]
    
    180도 (180도 반시계)              rot[N-1-i][M-1-j] = mat[i][j]
    
    207도 시계 (90도 반시계)     |       rot[M-1-j][i] = mat[i][j]


N*M 직사각형 기준

layer 단위로 순회, 한 칸씩 이동 (2,3) -> (2,4) 이런식으로 한 칸씩 다 옮겨줘야함
정사각형처럼 정해진 규칙이 따로 있진 않음.


    int N, M;
    int layers = min(N, M)/2; // layer를 기준점으로 중간 지점을 파악하고 구간별로 나눈다

    for(int layer=0; layer<layers; layer++){
        int top = layer, bottom = N-1-layer;
        int left = layer, right = M-1-layer;

        int prev = mat[top+1][left]; // 이동 시작점 저장

        // top row
        for(int j=left;j<=right;j++){
            swap(mat[top][j], prev);
        }

        // right column
        for(int i=top+1;i<=bottom;i++){
         
            swap(mat[i][right], prev);
        }
        // bottom row
        for(int j=right-1;j>=left;j--){
            swap(mat[bottom][j], prev);
        }

        // left column
        for(int i=bottom-1;i>top;i--){
            swap(mat[i][left], prev);
        }
    }

# 토러스맵

int nx = (현재 index + delta + size) % size

여기서 현재 index + delta 값이 음수인 경우를 방지하기 위해서 + size를 하는데 만약 음수값이 size보다 더 작은 경우,
좌표가 음수가 나올 수 있다. (좌표는 음수가 되어서는 안된다. (0,0) 부터 (n,n) 까지니까.

그래서

int nx = ((현재 index + delta)% size + size ) % size로 구현하면된다. -> 음수값이 발생할 수 있는 구간이면 % size 또는 + size ) % size를 통해서 양수로 올려주는 작업이 필요함.

magic_shark_fireball에서도 

        int nx = ((f.r + dx[f.d] * (f.s % N)) % N + N) % N;
        int ny = ((f.c + dy[f.d] * (f.s % N)) % N + N) % N;

이렇게 되는 이유가, f.s가 만약에 N 크기보다 더 커버리면 음수로 바로 진입할 가능성이 있음. 
(보통은 문제에서 제한을 걸지만, 해당 문제보면 s가 1000이라서 direction이 음수라면 순식간에 좌표 이탈함)
따라서 % N을 통해서 값을 정리해줘야 안정적으로 맵 안에 위치 할 수 있음. 이후 % N이나, + N 등 작업을 통해 음수 좌표가 안 나오도록 정리


----------------------------------------------------------------------------------------------------
🟦 비슷한 난이도 (골드4~골드3)

마법사 상어와 블리자드 (21611, 골드3)

구슬 파괴 → 이동 → 폭발 → 변화 과정을 시뮬레이션.

"상어 + 격자" 시리즈 중 파이어볼과 비슷한 난이도의 구현 난제.

마법사 상어와 파이어스톰 (20058, 골드4)

격자 회전 + 빙하 녹이기 + 덩어리 크기 탐색.

파이어볼보다 구현은 복잡, BFS/DFS까지 섞여서 난이도 ↑.

마법사 상어와 복제 (23290, 골드1)

물고기 이동 + 상어 이동(최적 선택) + 복제 과정을 반복.

시뮬레이션 꼼꼼함 요구, 파이어볼보다 난이도 한 단계 위.

🟥 더 어려운 난이도 (골드2~플래티넘)

청소년 상어 (19236, 골드2)

DFS + 시뮬레이션. 물고기 이동 후 상어가 최적 경로로 먹는 경우 탐색.

구현 난이도 + 백트래킹까지 들어가므로 파이어볼보다 확실히 어려움.

상어 중학교 (21609, 골드2)

블록 그룹 탐색, 제거, 중력 적용, 회전까지 시뮬레이션.

여러 조건(무지개 블록, 크기 우선순위, 좌표 우선순위)을 고려해야 해서 구현량 많음.

새로운 게임 2 (17837, 골드2)

말들의 이동, 방향 전환, 스택 관리.

자료구조 관리가 핵심이며 디버깅이 어려움.

주사위 굴리기 2 (23288, 골드3)

주사위 굴리기 + 점수 획득 BFS.

단순 구현에서 시작하지만 점수 계산과 이동 규칙 때문에 실수 잦음.

🟩 초고난도 (플래티넘급, 삼성 기출 상위)

아기 상어 (16236, 골드3) → 변형 문제 다수 있음.

BFS 기반, 최단 거리 탐색과 조건 처리 꼼꼼함 요구.

원판 돌리기 (17822, 골드3)

원판 회전 + 인접 수 제거/평균화.

구현 자체는 단순하지만 시뮬레이션 디테일이 많아 실수하기 좋음.

낚시왕 (17143, 골드1)

낚시왕 이동 + 상어 이동 + 충돌 처리.

격자에서 물체 이동 후 충돌 처리하는 전형적인 삼성 기출 스타일.

📌 난이도 정리 표
문제	난이도	특징
마법사 상어와 파이어볼 (20056)	골드4	기본 시뮬레이션, 파이어볼 이동/합체/분리
마법사 상어와 블리자드 (21611)	골드3	구슬 폭발 & 재배치
마법사 상어와 파이어스톰 (20058)	골드4	회전 + BFS 얼음 탐색
마법사 상어와 복제 (23290)	골드1	시뮬레이션 + 최적 선택
청소년 상어 (19236)	골드2	DFS + 시뮬레이션
상어 중학교 (21609)	골드2	그룹 탐색 + 중력/회전
새로운 게임 2 (17837)	골드2	말 이동, 스택 관리
주사위 굴리기 2 (23288)	골드3	주사위 규칙 + BFS 점수
아기 상어 (16236)	골드3	BFS + 조건 분기
낚시왕 (17143)	골드1	물체 이동 + 충돌 처리

