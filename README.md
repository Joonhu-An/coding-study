# 회전행렬
 
 N*N 정사각형 기준

              회전각            |         수식 (rot[i][j]에 mat[i][j] 복사)
              
    90도 시계  (270도 반시계)    |      rot[j][N-1-i] = mat[i][j]
    
    180도 (180도 반시계)              rot[N-1-i][M-1-j] = mat[i][j]
    
    207도 시계 (90도 반시계)     |       rot[M-1-j][i] = mat[i][j]


N*M 직사각형 기준

layer 단위로 순회, 한 칸씩 이동 (2,3) -> (2,4) 이런식으로 한 칸씩 다 옮겨줘야함
정사각형처럼 정해진 규칙이 따로 있진 않음.


    int N, M;
    int layers = min(N, M)/2; // layer를 기준점으로 중간 지점을 파악하고 구간별로 나눈다

    for(int layer=0; layer<layers; layer++){
        int top = layer, bottom = N-1-layer;
        int left = layer, right = M-1-layer;

        int prev = mat[top+1][left]; // 이동 시작점 저장

        // top row
        for(int j=left;j<=right;j++){
            swap(mat[top][j], prev);
        }

        // right column
        for(int i=top+1;i<=bottom;i++){
         
            swap(mat[i][right], prev);
        }
        // bottom row
        for(int j=right-1;j>=left;j--){
            swap(mat[bottom][j], prev);
        }

        // left column
        for(int i=bottom-1;i>top;i--){
            swap(mat[i][left], prev);
        }
    }

# 토러스맵

int nx = (현재 index + delta + size) % size

여기서 현재 index + delta 값이 음수인 경우를 방지하기 위해서 + size를 하는데 만약 음수값이 size보다 더 작은 경우,
좌표가 음수가 나올 수 있다. (좌표는 음수가 되어서는 안된다. (0,0) 부터 (n,n) 까지니까.

그래서

int nx = ((현재 index + delta)% size + size ) % size로 구현하면된다. -> 음수값이 발생할 수 있는 구간이면 % size 또는 + size ) % size를 통해서 양수로 올려주는 작업이 필요함.

magic_shark_fireball에서도 

        int nx = ((f.r + dx[f.d] * (f.s % N)) % N + N) % N;
        int ny = ((f.c + dy[f.d] * (f.s % N)) % N + N) % N;

이렇게 되는 이유가, f.s가 만약에 N 크기보다 더 커버리면 음수로 바로 진입할 가능성이 있음. 
(보통은 문제에서 제한을 걸지만, 해당 문제보면 s가 1000이라서 direction이 음수라면 순식간에 좌표 이탈함)
따라서 % N을 통해서 값을 정리해줘야 안정적으로 맵 안에 위치 할 수 있음. 이후 % N이나, + N 등 작업을 통해 음수 좌표가 안 나오도록 정리


----------------------------------------------------------------------------------------------------
🟦 비슷한 난이도 (골드4~골드3)

마법사 상어와 블리자드 (21611, 골드3)

구슬 파괴 → 이동 → 폭발 → 변화 과정을 시뮬레이션.

"상어 + 격자" 시리즈 중 파이어볼과 비슷한 난이도의 구현 난제.

마법사 상어와 파이어스톰 (20058, 골드4)

격자 회전 + 빙하 녹이기 + 덩어리 크기 탐색.

파이어볼보다 구현은 복잡, BFS/DFS까지 섞여서 난이도 ↑.

마법사 상어와 복제 (23290, 골드1)

물고기 이동 + 상어 이동(최적 선택) + 복제 과정을 반복.

시뮬레이션 꼼꼼함 요구, 파이어볼보다 난이도 한 단계 위.

🟥 더 어려운 난이도 (골드2~플래티넘)

청소년 상어 (19236, 골드2)

DFS + 시뮬레이션. 물고기 이동 후 상어가 최적 경로로 먹는 경우 탐색.

구현 난이도 + 백트래킹까지 들어가므로 파이어볼보다 확실히 어려움.

상어 중학교 (21609, 골드2)

블록 그룹 탐색, 제거, 중력 적용, 회전까지 시뮬레이션.

여러 조건(무지개 블록, 크기 우선순위, 좌표 우선순위)을 고려해야 해서 구현량 많음.

새로운 게임 2 (17837, 골드2)

말들의 이동, 방향 전환, 스택 관리.

자료구조 관리가 핵심이며 디버깅이 어려움.

주사위 굴리기 2 (23288, 골드3)

주사위 굴리기 + 점수 획득 BFS.

단순 구현에서 시작하지만 점수 계산과 이동 규칙 때문에 실수 잦음.

🟩 초고난도 (플래티넘급, 삼성 기출 상위)

아기 상어 (16236, 골드3) → 변형 문제 다수 있음.

BFS 기반, 최단 거리 탐색과 조건 처리 꼼꼼함 요구.

원판 돌리기 (17822, 골드3)

원판 회전 + 인접 수 제거/평균화.

구현 자체는 단순하지만 시뮬레이션 디테일이 많아 실수하기 좋음.

낚시왕 (17143, 골드1)

낚시왕 이동 + 상어 이동 + 충돌 처리.

격자에서 물체 이동 후 충돌 처리하는 전형적인 삼성 기출 스타일.

📌 난이도 정리 표
문제	난이도	특징
마법사 상어와 파이어볼 (20056)	골드4	기본 시뮬레이션, 파이어볼 이동/합체/분리
마법사 상어와 블리자드 (21611)	골드3	구슬 폭발 & 재배치
마법사 상어와 파이어스톰 (20058)	골드4	회전 + BFS 얼음 탐색
마법사 상어와 복제 (23290)	골드1	시뮬레이션 + 최적 선택
청소년 상어 (19236)	골드2	DFS + 시뮬레이션
상어 중학교 (21609)	골드2	그룹 탐색 + 중력/회전
새로운 게임 2 (17837)	골드2	말 이동, 스택 관리
주사위 굴리기 2 (23288)	골드3	주사위 규칙 + BFS 점수
아기 상어 (16236)	골드3	BFS + 조건 분기
낚시왕 (17143)	골드1	물체 이동 + 충돌 처리


--------------------------------------------------------------------------------------------------------------------------

회전 기반 문제 추천 리스트 (백준 기준 난이도 포함)

16926번 – 배열 돌리기 1

난이도: 실버 4

테두리부터 안쪽까지 “레이어(껍질)" 단위로 한 칸씩 돌리는 구현 문제. 기본 회전 로직 연습에 좋습니다.

개발 블로그

16927번 – 배열 돌리기 2

난이도: 실버 3

1번의 확장판으로, 회전 횟수가 매우 크다는 점(R ≤ 10⁹)에서 모듈러 연산 최적화가 필요합니다.

개발 블로그

17406번 – 배열 돌리기 4

난이도: 골드 4

여러 회전 연산 순서를 바꿔 결과 중 최소를 구해야 하는 문제. 회전 + 브루트포스 순열 탐색을 조합한 고난도 구현.

백준 온라인 저지
궤도

17276번 – 배열 돌리기 다국어

난이도: 실버 3

5×5 배열을 45° 단위로 회전하는 문제로, **비정형 회전(대각선 포함)**을 구현해야 하는 특별한 회전입니다.

백준 온라인 저지

20327번 – 배열 돌리기 6

난이도: 골드 3

ℓ 을 기준으로 부분 배열을 90° 회전하거나 반전시키는 여러 연산 중 하나를 선택해야 하는 문제. 회전 + 부분격자 + 다양한 연산 구현 복잡.

백준 온라인 저지

16935번 – 배열 돌리기 3

난이도: 실버 1

배열을 90° 단위로 여러 방향으로 회전하거나 뒤집기를 조합해 적용해서 출력하는 문제로, 회전 공식 응용 연습에 적합합니다. (검색 기반)

20058번 – 마법사 상어와 파이어스톰

난이도: 골드 4

현재까지 구현하신 바로 그 문제. 부분 격자 회전 + BFS 시뮬레이션, 복합적인 구현 난도가 특징입니다.

15812번 – 백트래킹 + 회전 패턴 문제

난이도: 골드 2

(예시) 특정 격자를 돌려가며 도형을 찾는 백트래킹 문제들. 회전 패턴 반복 구현이 핵심.

16930번 – 이동!

난이도: 골드 5

회전 행렬은 직접 안 다루지만, 슬라이딩(회전 유사 동작) 로직이 포함된 구현 문제로 혼동 가능, 난이도 고급.

10254번 – 고급 회전 변형 문제

난이도: 플래티넘

(가정) 복잡한 회전 + 최적화/분할 정복이 필요한 고난도 문제로, 구현 뿐 아니라 알고리즘 성능 고려가 필요함.
